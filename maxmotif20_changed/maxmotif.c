/* MaxMotif: enumerating all maximal motif appearing
  at least given t times in a given string */
/* 2006 Takeaki Uno */

#ifndef _maxmotif_c_
#define _maxmotif_c_

#include"seq.c"
#include"problem.c"

/**********************************************************************/
/**  Variable difinitiion */
/**********************************************************************/

// PP->len: ignore overlapping occurrences with at most PP->len non-overlap region 
// SS->s: input string ()
// SS->str_len: length of input string  

// SS->chr_num: number of alphabet

// PP->OQ: occurrences 
// PP->vecjump: queue for storing non-empty alphabets
// PP->oo: current occurrence

// SS->pat: pattern string
// SS->plen: length of pattern string
// SS->perr: #solid letters in pattern
// II->itemset: positions of solid letters

// II->sc: #pattern classified by thier sizes
// SS->plen_lb: LB for pattern length
// SS->plen_ub: UB for pattern length
// SS->err_min: LB for #solid letters
// SS->perr_max: UB for #solid letters
// II->frq_ub: upper bound for frequency

// II->frq: frequency of the current pattern
// II->frq_lb: LB for frequency
// PP->gap_ub: UB for #consecutive wildcards
// PP->num: UB for #wildcards


/* print usage */
void MaxMotif_error (){
 fprintf (stderr, "maxMotif: [FCfIq] [options] input-filename support [output-filename]\n\
%%:show progress, _:no message, +:write solutions in append mode\n\
F:frequent motif mining, C:closed (maximal) frequent motif mining\n\
D:count the frequency by document occurrence, c:multi string comparison\n\
i:ignore \\n(cr: newline) of input string\n\
G:genome sequence mode, J:(In genome mode), regard '>'\n\
(comment) as a separator, J:(maxmotif16)read text in Japanese EUC mode\n\
J:(maxmotif32) regard each byte as 1 digit of at most 200 (32 -> 0,..., 231 -> 199)\n\
0:read number-sequence file\n\
f:output frequency, q:no output to standard output\n\
I:output positions of occurrences, J:read text in Japanese EUC mode (16bit-mode)\n\
d:output string IDs, p:do not output positions, n:normalize positions of all strings\n\
[options]\n\
-2 [filename]:read additional file, attached to the input file\n\
-d [num]:duplicate strings from [num]th to the end\n\
-3 [num]:matrix mode for each string up to [num]th (all strings if 0 is given)\n\
-r [num]:reverse strings from [num]th string to the last string\n\
-l [num]:output patterns with size at least [num]\n\
-u [num]:output pattenrs with size at most [num]\n\
-L [num]:output patterns with at least [num] solid letters\n\
-U [num]:output patterns with at most [num] solid letters\n\
-p [num]:upper bound for quorum (or support, maximum support)\n\
-m [num]:upper bound for wildcards\n\
-c [num]:upper bound for consecutive wildcards\n\
-R [num]:reduce redundant patterns with non-overlapping region of at most [num] charactors\n\
-w [char]:specify character for wildcard in the output file\n\
-W [char]:specify character for wildcard for working memory\n\
-# [num]:stop after outputting [num] solutions\n\
\nfor -d, -3, and -r options, [num] will be set to the first string in the second file, or the half of strings (except for -d), if [num] is -1. [num] will be set to the ID of top string generated by -d option if [num] is -2.\n\
# the 1st letter of input-filename cannot be '-'.\n\
# if the output file name is -, the solutions will be output to standard output.\n");
 exit(1);
}

/***********************************************************************/
/*  read parameters given by command line  */
/***********************************************************************/
void MaxMotif_read_param (INT argc, char *argv[], PROBLEM *PP){
  INT c=1;
  ITEMSET *II = &PP->II;
  SEQ *SS = &PP->SS;

  SS->plen_ub = 0;
  SS->wildcard = '#';
  PP->num = -1;
  if ( argc <= c+2 ) MaxMotif_error ();

  if ( !strchr (argv[c], '_') ){ II->flag |= SHOW_MESSAGE; SS->flag |= SHOW_MESSAGE; }
  if ( strchr (argv[c], '%') ) II->flag |= SHOW_PROGRESS;
  if ( strchr (argv[c], '+') ) II->flag |= ITEMSET_APPEND;
  if ( strchr (argv[c], 'C') ) PP->problem |= PROBLEM_CLOSED;
  else if ( strchr (argv[c], 'F') ) PP->problem |= PROBLEM_FREQSET;
  if ( strchr (argv[c], 'D') ) PP->problem |= PROBLEM_DOC;
  if ( strchr (argv[c], 'c') ) SS->flag |= SEQ_MULTI_STRING;
  if ( strchr (argv[c], 'i') ) SS->flag |= SEQ_IGNORE_NEWLINE;
  if ( strchr (argv[c], 'f') ) II->flag |= ITEMSET_FREQ;
  if ( strchr (argv[c], 'I') ) II->flag |= ITEMSET_TRSACT_ID;
  if ( strchr (argv[c], 'G') ) SS->flag |= SEQ_GENOME;
  if ( strchr (argv[c], 'J') ) SS->flag |= SEQ_EUC;
  if ( strchr (argv[c], '0') ) SS->flag |= SEQ_NUM;
  if ( strchr (argv[c], 'd') ) SS->flag |= SEQ_OUTPUT_ID;
  if ( strchr (argv[c], 'p') ) SS->flag |= SEQ_NO_OUTPUT_POSITION;
  c++;
  
  while ( argv[c][0] == '-' ){
    switch (argv[c][1]){
      case '2': PP->SS.fname2 = argv[c+1];
      break; case '3': if ( (SS->matrix_by = atoi(argv[c+1])) < -3 || atoi(argv[c+1]) == 0 )
          error_num("string ID has to be positive, -1 -2, or -3",atof(argv[c+1]), EXIT);
        if ( SS->matrix_by == 0 ) SS->matrix_by = INTHUGE;
        if ( SS->ylen == 0 ){ SS->ylen = 1; SS->flag |= SEQ_SEGMENT; }
      break; case 'd': if ( (SS->duplicated_by = atoi(argv[c+1])) < -2 || atoi(argv[c+1]) == 0 )
          error_num("string ID has to be positive, -1 or -2",atof(argv[c+1]), EXIT);
      break; case 'r': if ( atoi(argv[c+1]) < -3 || atoi(argv[c+1]) == 0 )
          error_num("string ID has to be positive, -1 or -2",atof(argv[c+1]), EXIT);
          SS->reversed_by = atoi(argv[c+1]);
      break; case 'l': if ( (SS->plen_lb = atoi(argv[c+1])) <= 0 )
          error_num("lower bound for pattern length has to be positive",atof(argv[c+1]), EXIT);
      break; case 'u': if ( (SS->plen_ub = atoi(argv[c+1])) <= 0 )
          error_num("upper bound for pattern length has to be positive",atof(argv[c+1]), EXIT);
      case 'L': if ( (SS->perr_min = atoi(argv[c+1])) <= 0 )
          error_num("lower bound for #solid letters in pattern has to be positive",atof(argv[c+1]), EXIT);
      break; case 'U': if ( (SS->perr_max = atoi(argv[c+1])) <= 0 )
          error_num("upper bound for #solid letters in pattern has to be positive",atof(argv[c+1]), EXIT);
      break; case 'p': if ( (II->frq_ub = atoi(argv[c+1])) <= 0 )
          error_num("frequency upper bound has to be positive",atof(argv[c+1]), EXIT);
      break; case 'c': if ( (PP->gap_ub = atoi(argv[c+1])) <= 0 )
          error_num("upper bound for #consecutive wildcards has to be positive",atof(argv[c+1]), EXIT);
      break; case 'm': if ( (PP->num = atoi(argv[c+1])) < 0 )
          error_num("upper bound for #wildcards has to be positive",atof(argv[c+1]), EXIT);
      break; case 'w': SS->wildcard = argv[c+1][0];
      break; case 'W': if ( SS->wfname ) SS->wfname2 = argv[c+1]; else SS->wfname = argv[c+1];
      break; case 'R': PP->len = atoi (argv[c+1]); PP->problem |= PROBLEM_EX_CLOSED;
      break; case '#': II->max_solutions = atoi(argv[c+1]);
      break; default: goto NEXT;
    }
    c += 2;
    if ( argc < c+2) MaxMotif_error ();
  }

  NEXT:;
  II->frq_lb = atoi(argv[c+1]);
  PP->SS.fname = argv[c];
  if ( argc>c+2 ) PP->output_fname = argv[c+2];
}


  /**************************************************************/
  /*  Alphabet count, and allocate memory for OQ (occurrences)  */
  /**************************************************************/
void MaxMotif_alloc_occ (PROBLEM *PP){
  SEQ_ID i;
  SEQ_LONG j, jj=0;
  SEQ *SS = &PP->SS;
  
  FLOOP (i, 1, SS->str_num) jj += SS->tail[i] - SS->head[i];
  calloc2 (PP->OQ, SS->chr_num, EXIT);
  calloc2 (PP->OQ[0].v, jj+ SS->chr_num, EXIT);
  FLOOP (i, 1, SS->str_num)
      FLOOP (j, SS->head[i], SS->tail[i]) PP->OQ[SS->s[j]].end++;
  FLOOP (i, 0, SS->chr_num-1)
      PP->OQ[i+1].v = PP->OQ[i].v + PP->OQ[i].end +1;
}

   /********************************/
   /**  output a pattern to file  **/ 
   /********************************/
void MaxMotif_output_pattern (PROBLEM *PP, QUEUE *deno){
  QUEUE_ID i;
  QUEUE_INT *e, x;
  SEQ_ID sx;
  SEQ *SS = &PP->SS;
  ITEMSET *II = &PP->II;
  char c = PP->II.separator;

  II->multi_outputs[0]++;
  if ( SS->perr < SS->perr_min || SS->perr > SS->perr_max 
    || II->frq > II->frq_ub || II->frq < II->frq_lb 
    || SS->plen < SS->plen_lb || SS->plen - SS->perr > PP->num ) return;

  if ( II->fp ){
    FLOOP (i, 0, SS->plen){
      if ( SS->flag & SEQ_NUM ){
        if ( SS->pat[i] == SS->chr_num-1 ) fprintf (II->fp, "%c ", SS->wildcard);
        else fprintf (II->fp, "%d ", SS->unperm[SS->pat[i]]);
      } else fputc (SS->unperm[SS->pat[i]], II->fp);
    }
    if ( II->flag & ITEMSET_FREQ ) fprintf (II->fp, "  (" WEIGHTF ")", II->frq);
    fprintf (II->fp, "\n");
    if ( II->flag & ITEMSET_TRSACT_ID ){
      MQUE_FLOOP (*deno, e){
        x = *e;
        sx = SEQ_get_substID (SS, *e);
        if ( SS->flag&SEQ_OUTPUT_ID ){ x -= SS->head[sx]; fprintf (II->fp, "%d%c", sx, c); }
        if ( (SS->flag&SEQ_SEGMENT) && *e<SS->matrix_pos ){
          x = (*e - SS->head[sx]) % SS->clms[sx];
          fprintf (II->fp, "%d%c", (*e - SS->head[sx])/SS->clms[sx], c);
        }
        if ( !(SS->flag & SEQ_NO_OUTPUT_POSITION) ) fprintf (II->fp, "%d%c", x, c);
      }
      fprintf (II->fp, "\n");
    }
  }
  II->sc[SS->plen]++;
  if ( II->max_solutions>0 && II->multi_solutions[0] > II->max_solutions ){
    ITEMSET_last_output (&PP->II);
    ERROR_MES = "reached to maximum number of solutions";
    EXIT;
  }
//  II->sc2[SS->err]++;
}

  /*******************************************************************/
  /**  Fix & Unfix one letter  **/
  /*******************************************************************/
void MaxMotif_fix_letter (PROBLEM *PP, INT d, SEQ_CHAR c){
  PP->SS.pat[d] = c;
  QUE_INS (PP->II.itemset, d);
  PP->SS.plen = d+1;
  PP->SS.perr++;
}

void MaxMotif_delete_fixed_letter (PROBLEM *PP){
  QUEUE_ID i;
  FLOOP (i, PP->II.itemset.s, PP->II.itemset.t){
    PP->SS.pat[PP->II.itemset.v[i]] = PP->SS.chr_num-1;
    PP->SS.perr--;
  }
  PP->II.itemset.t = PP->II.itemset.s;
}

  /*******************************************************************/
  /**  Occurrence Deliver  **/
  /*******************************************************************/
void MaxMotif_occ_deliver (PROBLEM *PP, QUEUE *deno,INT d){
  INT c, p = PP->problem&PROBLEM_DOC;
  SEQ_ID sx;
  QUEUE_INT *e, *ee;
  SEQ *SS = &PP->SS;
  PP->vecjump.t = 0;
  MQUE_FLOOP (*deno, e){
    sx = SEQ_get_substID (&PP->SS, *e);
    if ( (SS->flag&SEQ_SEGMENT) && *e<SS->matrix_pos ){
      if ( ((*e - SS->head[sx])%SS->clms[sx]) + d >= SS->clms[sx] ) continue;
    } else if ( *e+d >= SS->tail[sx] ) continue;

    c = SS->s[*e+d];
    if ( PP->OQ[c].t == 0 ) QUE_INS (PP->vecjump, c);
    QUE_INS (PP->OQ[c], *e);
    if ( p ) continue;  // document occurrence is computed later
    PP->occ_w[c] += SS->str_w[sx];
    if ( SS->str_w[sx] > 0 ) PP->occ_pw[c] += SS->str_w[sx];
  }
  if ( !p ) return;
  
  MQUE_FLOOP (PP->vecjump, ee){  // compute document occurrence
    MQUE_FLOOP (PP->OQ[*ee], e){
      sx = SEQ_get_substID (&PP->SS, *e);
      if ( PP->vf[sx] ) continue;
      PP->vf[sx] = 1;
      PP->occ_w[*ee] += SS->str_w[sx];
      if ( SS->str_w[sx] > 0 ) PP->occ_pw[*ee] += SS->str_w[sx];
    }
    MQUE_FLOOP (PP->OQ[*ee], e)  // erase the marks
        PP->vf[ SEQ_get_substID (&PP->SS, *e)] = 0;
  }
}

  /*******************************************************************/
  /**  Copy Occ's for backup during recursive calls, and clear occ's */
  /*******************************************************************/
QUEUE *MaxMotif_copy_occ (PROBLEM *PP, INT *num, WEIGHT **frq){
  INT *mem;
  size_t nn=0;
  QUEUE_INT *e;
  QUEUE *occ;
  *num=0; MQUE_FLOOP (PP->vecjump, e)
      if ( PP->occ_pw[*e] >= PP->II.frq_lb ){ (*num)++; nn += PP->OQ[*e].t; }
  if ( *num == 0 ){
    MQUE_FLOOP (PP->vecjump, e){
      PP->OQ[*e].t = 0;
      PP->occ_w[*e] = PP->occ_pw[*e] = 0;
    }
    return (NULL);
  }
  malloc2 (mem, nn, EXIT);
  calloc2 (occ, *num, EXIT);
  malloc2 (*frq, *num, EXIT);
  nn=0; MQUE_FLOOP (PP->vecjump, e){
    if ( PP->occ_pw[*e] >= PP->II.frq_lb ){
      occ[nn].end = *e;
      occ[nn].t = PP->OQ[*e].t;
      occ[nn].v = mem;
      (*frq)[nn] = PP->occ_w[*e];
      memcpy (occ[nn].v, PP->OQ[*e].v, sizeof(QUEUE_INT)*occ[nn].t );
      mem += occ[nn].t;
      nn++;
    }
    PP->OQ[*e].t = 0;
    PP->occ_w[*e] = PP->occ_pw[*e] = 0;
  }
  return (occ);
}


  /*********************************************************/
  /* if all letters on "deno"+d are the same, return it.   */
  /* return -1 otherwise                                   */
  /*********************************************************/
INT MaxMotif_check_same (PROBLEM *PP, QUEUE *deno, INT d){
  SEQ *SS = &PP->SS;
  INT i, m=SS->s[deno->v[0]+d], e;
  INT gap = MIN(SS->plen, PP->len);
  FLOOP (i, 1, deno->t){
    e = deno->v[i];
    if ( SS->plen == 0 || (PP->problem&PROBLEM_EX_CLOSED)==0 || deno->v[i-1]+gap<e )
      if ( m != SS->s[e+d] ) return (-1);
  }
  return (m);
}

INT MaxMotif_ppc_check (PROBLEM *PP, QUEUE *deno, INT d){
  INT i, omin=PP->SS.str_len;
  SEQ *SS = &PP->SS;
  SEQ_ID sx;
  QUEUE_INT *e;
  
  MQUE_FLOOP (*deno, e){
    sx = SEQ_get_substID (SS, *e);
    if ( (SS->flag&SEQ_SEGMENT) && *e<SS->matrix_pos ){
      ENMIN (omin, (*e - SS->head[sx]) % SS->clms[sx]);
    } else ENMIN (omin, *e - SS->head[sx]);
  }
  FLOOP (i, MAX(-omin, -PP->gap_ub-1), d){
    if ( i<0 || PP->SS.pat[i]==PP->SS.chr_num-1 ){
      if ( MaxMotif_check_same (PP, deno, i) >= 0 ) return (0);
    }
  }
  return (1);
}

void MaxMotif_append_closure (PROBLEM *PP, QUEUE *deno, INT d, INT pmax){
  QUEUE_ID i;
  INT c, dmax = MIN (d+PP->gap_ub+1, pmax);

  FLOOP (i, d, dmax){
    if ( PP->SS.pat[i] != PP->SS.chr_num-1 ){
      PP->SS.plen = i+1;
      dmax = MIN (i+PP->gap_ub+1, pmax);
      continue;
    }
    c = MaxMotif_check_same (PP, deno, i);
    if ( c >= 0 ){
      MaxMotif_fix_letter (PP, i, c);
      dmax = MIN (i+PP->gap_ub+1, pmax);
    }
  }
}

  /*******************************************************************/
  /**  Iteration of MaxMotif */
  /*******************************************************************/
void MaxMotif_iter (PROBLEM *PP, QUEUE *deno, INT core_i){
  ITEMSET *II = &PP->II;
  SEQ *SS = &PP->SS;
  QUEUE_INT *e, ee;
  SEQ_ID sx;
  QUEUE *occ;
  QUEUE_ID i, j, occ_siz, js = II->itemset.s;
  INT psiz = SS->plen;
  SEQ_LONG msiz = SS->plen_ub, siz=0;
  WEIGHT *frq;

  II->iters++;
    // determin maximum extend length
  if ( core_i<0 ) siz = 1;
  else {
    MQUE_FLOOP (*deno, e){
      sx = SEQ_get_substID (SS, *e);
      if ( (SS->flag&SEQ_SEGMENT) && *e<SS->matrix_pos ){
        ee = *e - SS->head[sx];
        ee = SS->clms[sx] - (ee % SS->clms[sx]);
      } else ee = SS->tail[sx] - *e;
      ENMAX (siz, ee);
      ENMIN (msiz, ee);
    }
    if ( PP->problem & PROBLEM_CLOSED )
        MaxMotif_append_closure (PP, deno, core_i+1, msiz);
  }

  MaxMotif_output_pattern (PP, deno);
  II->itemset.s = II->itemset.t;
  ENMIN (siz, MIN (core_i+PP->gap_ub+2, SS->plen_ub));
  ENMIN (siz, 1+SS->perr + PP->num);

  FLOOP (i, core_i+1, siz){
    if ( SS->pat[i] == SS->chr_num-1 ){
      MaxMotif_occ_deliver (PP, deno, i);
      occ = MaxMotif_copy_occ (PP, &occ_siz, &frq);
      if ( occ_siz>0 ){
        FLOOP (j, 0, occ_siz){
          if ( ((PP->problem&PROBLEM_CLOSED)==0) || MaxMotif_ppc_check(PP, &occ[j], i) ){
            MaxMotif_fix_letter (PP, i, occ[j].end);
            II->frq = frq[j];   // new
            MaxMotif_iter (PP, &occ[j], i);
            MaxMotif_delete_fixed_letter (PP);
            SS->plen = psiz;
          } else if ( PP->problem&PROBLEM_CLOSED ) II->iters2++;
        }
        free2 (occ[0].v);
        free2 (occ);
        free2 (frq);
      }
    }
  }
  II->itemset.s = js;
}


  /********************/
  /*  initialization  */
  /********************/
void MaxMotif_init (PROBLEM *PP){
  SEQ_ID i;
  SEQ_LONG j, jj=1;
  SEQ *SS = &PP->SS;

  SS->flag |= SEQ_STR_W;
  PROBLEM_load (PP);
  if ( SS->plen_ub == 0 ) SS->plen_ub = MIN(10000, SS->str_len);
  SS->unperm[SS->chr_num] = SS->wildcard;
  SS->chr_num++;  // for wildcard (wildcard = SS->chr_num <- the last character)

  PROBLEM_alloc (PP, SS->plen_ub, SS->chr_num, SS->plen_ub, 0, PROBLEM_VECJUMP+PROBLEM_OCC_W+PROBLEM_OCC_PW);
  if ( !SS->wfname ) FLOOP (i, 0, SS->str_num) SS->str_w[i] = 1;  // uniform weight
  MaxMotif_alloc_occ (PP);
  calloc2 (SS->pat, SS->plen_ub, EXIT);
  calloc2 (PP->vf, SS->str_num, EXIT);
  ARY_FILL (SS->pat, 0, SS->plen_ub, SS->chr_num-1);

  FLOOP (i, 1, SS->str_num){
    if ( (SS->flag&SEQ_SEGMENT) && i<SS->matrix_by ){
      if ( SS->clms[i] >= SS->plen_lb )
        jj += (SS->clms[i]-SS->plen_lb+1) * ((SS->tail[i]-SS->head[i]) /SS->clms[i] +1);
    } else if ( SS->tail[i] - SS->head[i] >= SS->plen_lb ) 
        jj += SS->tail[i] - SS->head[i] - SS->plen_lb+1;
  }
  QUEUE_alloc (&PP->oo, jj);
  FLOOP (i, 1, SS->str_num){
    FLOOP (j, SS->head[i], SS->tail[i]-SS->plen_lb+1){
      if ( (SS->flag&SEQ_SEGMENT) && j<SS->matrix_pos ){
        if ( SS->clms[i] - ((j - SS->head[i])%SS->clms[i]) < SS->plen_lb ) continue;
      }
      QUE_INS (PP->oo, j);
    }
  }
  if ( PP->num == -1 ) PP->num = PP->SS.str_len;
//  MaxMotif_sc2 = intarray_malloc_const ( SS->plen_ub+1, 0);
}


/*******************************************************************/

INT MaxMotif_main (INT argc, char *argv[]){
  PROBLEM PP;

  PROBLEM_init (&PP);
  MaxMotif_read_param (argc, argv, &PP);
if ( ERROR_MES ) goto END;
  MaxMotif_init (&PP);
if ( ERROR_MES ) goto END;
  MaxMotif_iter (&PP, &PP.oo, -1);

  ITEMSET_last_output (&PP.II);

  END:;
//  PP.OQ[0].v = PP.buf;
  PROBLEM_end (&PP);
  return (0);
}

/*******************************************************************************/
#ifndef _NO_MAIN_
#define _NO_MAIN_
int main (int argc, char *argv[]){
  return (MaxMotif_main (argc, argv) );
}
#endif
/*******************************************************************************/

#endif


